{"ast":null,"code":"// A simple linear regression model to predict efficiency based on\n// engine hours, idle hours, and fuel usage.\nconst mlModel = {\n  // These weights are manually determined for this example.\n  // In a real-world scenario, these would be trained on historical data.\n  weights: {\n    engineHours: 0.5,\n    idleHours: -0.8,\n    fuelUsage: -0.2,\n    bias: 50 // Base efficiency score\n  },\n  // Predicts an efficiency score from 0-100\n  predict: data => {\n    const score = mlModel.weights.engineHours * parseFloat(data['Engine Hours/Day'] || 0) + mlModel.weights.idleHours * parseFloat(data['Idle Hours/Day'] || 0) + mlModel.weights.fuelUsage * parseFloat(data['Fuel Usage/Day (Liters)'] || 0) + mlModel.weights.bias;\n\n    // Clamp the score between 0 and 100\n    return Math.max(0, Math.min(100, score)).toFixed(2);\n  }\n};\nexport const addEfficiencyScores = equipmentData => {\n  return equipmentData.map(item => ({\n    ...item,\n    'Efficiency': mlModel.predict(item)\n  }));\n};\nexport const calculateOperatorScores = equipmentData => {\n  const operatorData = {};\n  const today = new Date();\n  equipmentData.forEach(item => {\n    const operatorId = item['Operator ID'];\n    if (operatorId && operatorId !== 'NULL') {\n      if (!operatorData[operatorId]) {\n        operatorData[operatorId] = {\n          rentals: [],\n          totalEngineHours: 0,\n          totalIdleHours: 0,\n          overdueCount: 0\n        };\n      }\n      operatorData[operatorId].rentals.push(item);\n      operatorData[operatorId].totalEngineHours += parseFloat(item['Engine Hours/Day'] || 0);\n      operatorData[operatorId].totalIdleHours += parseFloat(item['Idle Hours/Day'] || 0);\n      const plannedCheckInDate = new Date(item['Planned Check-In Date']);\n      if (!item['Actual Check-In Date'] && plannedCheckInDate < today) {\n        operatorData[operatorId].overdueCount++;\n      }\n    }\n  });\n  const operatorScores = Object.keys(operatorData).map(operatorId => {\n    const data = operatorData[operatorId];\n    const totalOperatingDays = data.rentals.reduce((sum, item) => sum + parseFloat(item['Operating Days'] || 0), 0);\n    const avgEngineHours = data.totalEngineHours / data.rentals.length;\n    const avgIdleHours = data.totalIdleHours / data.rentals.length;\n\n    // A linear model for operator performance.\n    // Higher average engine hours and lower average idle hours increase the score.\n    // Overdue rentals significantly decrease the score.\n    const score = avgEngineHours * 5 - avgIdleHours * 2 - data.overdueCount * 10 + 50;\n    return {\n      'Operator ID': operatorId,\n      'Number of Rentals': data.rentals.length,\n      'Average Engine Hours': avgEngineHours.toFixed(2),\n      'Average Idle Hours': avgIdleHours.toFixed(2),\n      'Overdue Rentals': data.overdueCount,\n      'Operator Score': Math.max(0, Math.min(100, score)).toFixed(2)\n    };\n  });\n  return operatorScores;\n};","map":{"version":3,"names":["mlModel","weights","engineHours","idleHours","fuelUsage","bias","predict","data","score","parseFloat","Math","max","min","toFixed","addEfficiencyScores","equipmentData","map","item","calculateOperatorScores","operatorData","today","Date","forEach","operatorId","rentals","totalEngineHours","totalIdleHours","overdueCount","push","plannedCheckInDate","operatorScores","Object","keys","totalOperatingDays","reduce","sum","avgEngineHours","length","avgIdleHours"],"sources":["D:/ts/my-dashboard/src/mlService.js"],"sourcesContent":["// A simple linear regression model to predict efficiency based on\r\n// engine hours, idle hours, and fuel usage.\r\nconst mlModel = {\r\n  // These weights are manually determined for this example.\r\n  // In a real-world scenario, these would be trained on historical data.\r\n  weights: {\r\n    engineHours: 0.5,\r\n    idleHours: -0.8,\r\n    fuelUsage: -0.2,\r\n    bias: 50, // Base efficiency score\r\n  },\r\n\r\n  // Predicts an efficiency score from 0-100\r\n  predict: (data) => {\r\n    const score = (\r\n      mlModel.weights.engineHours * parseFloat(data['Engine Hours/Day'] || 0) +\r\n      mlModel.weights.idleHours * parseFloat(data['Idle Hours/Day'] || 0) +\r\n      mlModel.weights.fuelUsage * parseFloat(data['Fuel Usage/Day (Liters)'] || 0) +\r\n      mlModel.weights.bias\r\n    );\r\n\r\n    // Clamp the score between 0 and 100\r\n    return Math.max(0, Math.min(100, score)).toFixed(2);\r\n  },\r\n};\r\n\r\nexport const addEfficiencyScores = (equipmentData) => {\r\n  return equipmentData.map(item => ({\r\n    ...item,\r\n    'Efficiency': mlModel.predict(item),\r\n  }));\r\n};\r\n\r\nexport const calculateOperatorScores = (equipmentData) => {\r\n  const operatorData = {};\r\n  const today = new Date();\r\n\r\n  equipmentData.forEach(item => {\r\n    const operatorId = item['Operator ID'];\r\n    if (operatorId && operatorId !== 'NULL') {\r\n      if (!operatorData[operatorId]) {\r\n        operatorData[operatorId] = {\r\n          rentals: [],\r\n          totalEngineHours: 0,\r\n          totalIdleHours: 0,\r\n          overdueCount: 0\r\n        };\r\n      }\r\n      operatorData[operatorId].rentals.push(item);\r\n      operatorData[operatorId].totalEngineHours += parseFloat(item['Engine Hours/Day'] || 0);\r\n      operatorData[operatorId].totalIdleHours += parseFloat(item['Idle Hours/Day'] || 0);\r\n\r\n      const plannedCheckInDate = new Date(item['Planned Check-In Date']);\r\n      if (!item['Actual Check-In Date'] && plannedCheckInDate < today) {\r\n        operatorData[operatorId].overdueCount++;\r\n      }\r\n    }\r\n  });\r\n\r\n  const operatorScores = Object.keys(operatorData).map(operatorId => {\r\n    const data = operatorData[operatorId];\r\n    const totalOperatingDays = data.rentals.reduce((sum, item) => sum + parseFloat(item['Operating Days'] || 0), 0);\r\n    const avgEngineHours = data.totalEngineHours / data.rentals.length;\r\n    const avgIdleHours = data.totalIdleHours / data.rentals.length;\r\n    \r\n    // A linear model for operator performance.\r\n    // Higher average engine hours and lower average idle hours increase the score.\r\n    // Overdue rentals significantly decrease the score.\r\n    const score = (\r\n      (avgEngineHours * 5) - (avgIdleHours * 2) - (data.overdueCount * 10) + 50\r\n    );\r\n\r\n    return {\r\n      'Operator ID': operatorId,\r\n      'Number of Rentals': data.rentals.length,\r\n      'Average Engine Hours': avgEngineHours.toFixed(2),\r\n      'Average Idle Hours': avgIdleHours.toFixed(2),\r\n      'Overdue Rentals': data.overdueCount,\r\n      'Operator Score': Math.max(0, Math.min(100, score)).toFixed(2)\r\n    };\r\n  });\r\n\r\n  return operatorScores;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}