{"ast":null,"code":"// A simple linear regression model to predict efficiency based on\n// engine hours, idle hours, and fuel usage.\nconst mlModel = {\n  // These weights are manually determined for this example.\n  // In a real-world scenario, these would be trained on historical data.\n  weights: {\n    engineHours: 0.5,\n    idleHours: -0.8,\n    fuelUsage: -0.2,\n    bias: 50 // Base efficiency score\n  },\n  // Predicts an efficiency score from 0-100\n  predict: data => {\n    const score = mlModel.weights.engineHours * parseFloat(data['Engine Hours/Day'] || 0) + mlModel.weights.idleHours * parseFloat(data['Idle Hours/Day'] || 0) + mlModel.weights.fuelUsage * parseFloat(data['Fuel Usage/Day (Liters)'] || 0) + mlModel.weights.bias;\n\n    // Clamp the score between 0 and 100\n    return Math.max(0, Math.min(100, score)).toFixed(2);\n  }\n};\nexport const addEfficiencyScores = equipmentData => {\n  return equipmentData.map(item => ({\n    ...item,\n    'Efficiency': mlModel.predict(item)\n  }));\n};\nexport const calculateOperatorScores = equipmentData => {\n  const operatorData = {};\n  const today = new Date();\n  equipmentData.forEach(item => {\n    const operatorId = item['Operator ID'];\n    if (operatorId && operatorId !== 'NULL') {\n      if (!operatorData[operatorId]) {\n        operatorData[operatorId] = {\n          rentals: [],\n          totalEngineHours: 0,\n          totalIdleHours: 0,\n          overdueCount: 0\n        };\n      }\n      operatorData[operatorId].rentals.push(item);\n      operatorData[operatorId].totalEngineHours += parseFloat(item['Engine Hours/Day'] || 0);\n      operatorData[operatorId].totalIdleHours += parseFloat(item['Idle Hours/Day'] || 0);\n      const plannedCheckInDate = new Date(item['Planned Check-In Date']);\n      if (!item['Actual Check-In Date'] && plannedCheckInDate < today) {\n        operatorData[operatorId].overdueCount++;\n      }\n    }\n  });\n  const operatorScores = Object.keys(operatorData).map(operatorId => {\n    const data = operatorData[operatorId];\n    const avgEngineHours = data.totalEngineHours / data.rentals.length;\n    const avgIdleHours = data.totalIdleHours / data.rentals.length;\n\n    // A linear model for operator performance.\n    // Higher average engine hours and lower average idle hours increase the score.\n    // Overdue rentals significantly decrease the score.\n    const score = avgEngineHours * 5 - avgIdleHours * 2 - data.overdueCount * 10 + 50;\n    return {\n      'Operator ID': operatorId,\n      'Number of Rentals': data.rentals.length,\n      'Average Engine Hours': avgEngineHours.toFixed(2),\n      'Average Idle Hours': avgIdleHours.toFixed(2),\n      'Overdue Rentals': data.overdueCount,\n      'Operator Score': Math.max(0, Math.min(100, score)).toFixed(2)\n    };\n  });\n  return operatorScores;\n};\nexport const demandForecasting = equipmentData => {\n  const demandPatterns = {};\n  equipmentData.forEach(item => {\n    const siteId = item['Site ID'];\n    const type = item['Type'];\n    if (siteId && type) {\n      if (!demandPatterns[siteId]) {\n        demandPatterns[siteId] = {};\n      }\n      demandPatterns[siteId][type] = (demandPatterns[siteId][type] || 0) + 1;\n    }\n  });\n  const forecasts = Object.keys(demandPatterns).map(siteId => {\n    const types = demandPatterns[siteId];\n    const mostDemandedType = Object.keys(types).reduce((a, b) => types[a] > types[b] ? a : b);\n    return {\n      'Site ID': siteId,\n      'Most Demanded Type': mostDemandedType,\n      'Confidence': (types[mostDemandedType] / Object.values(types).reduce((a, b) => a + b, 0) * 100).toFixed(2) + '%'\n    };\n  });\n  return forecasts;\n};\nexport const detectAnomalies = equipmentData => {\n  const anomalies = [];\n  const idleThreshold = 5;\n  const fuelUsageRatioThreshold = 6;\n  equipmentData.forEach(item => {\n    const isRented = !item['Actual Check-In Date'];\n    const hasLongIdleHours = parseFloat(item['Idle Hours/Day']) > idleThreshold;\n    const isUnassigned = !item['Site ID'] || item['Site ID'] === 'NULL';\n    const fuelUsage = parseFloat(item['Fuel Usage/Day (Liters)'] || 0);\n    const engineHours = parseFloat(item['Engine Hours/Day'] || 0);\n    const hasHighFuelUsage = engineHours > 0 && fuelUsage / engineHours > fuelUsageRatioThreshold;\n    const operatorId = item['Operator ID'] && item['Operator ID'] !== 'NULL' ? item['Operator ID'] : 'N/A';\n    if (isRented && hasLongIdleHours) {\n      anomalies.push({\n        'Equipment ID': item['Equipment ID'],\n        'Equipment Type': item['Type'],\n        'Operator ID': operatorId,\n        // Corrected\n        'Type': 'High Idle Hours',\n        'Details': `Idle time is ${item['Idle Hours/Day']} hours/day, exceeding the threshold of ${idleThreshold}.`\n      });\n    }\n    if (isRented && isUnassigned) {\n      anomalies.push({\n        'Equipment ID': item['Equipment ID'],\n        'Equipment Type': item['Type'],\n        'Operator ID': operatorId,\n        'Type': 'Unassigned Equipment',\n        'Details': `This equipment has been checked out but is not assigned to a site.`\n      });\n    }\n    if (isRented && hasHighFuelUsage) {\n      anomalies.push({\n        'Equipment ID': item['Equipment ID'],\n        'Equipment Type': item['Type'],\n        'Operator ID': operatorId,\n        'Type': 'High Fuel Usage',\n        'Details': `Fuel usage is ${fuelUsage.toFixed(2)} L/day for only ${engineHours.toFixed(2)} engine hours. Ratio exceeds ${fuelUsageRatioThreshold} L/hr.`\n      });\n    }\n  });\n  return anomalies;\n};","map":{"version":3,"names":["mlModel","weights","engineHours","idleHours","fuelUsage","bias","predict","data","score","parseFloat","Math","max","min","toFixed","addEfficiencyScores","equipmentData","map","item","calculateOperatorScores","operatorData","today","Date","forEach","operatorId","rentals","totalEngineHours","totalIdleHours","overdueCount","push","plannedCheckInDate","operatorScores","Object","keys","avgEngineHours","length","avgIdleHours","demandForecasting","demandPatterns","siteId","type","forecasts","types","mostDemandedType","reduce","a","b","values","detectAnomalies","anomalies","idleThreshold","fuelUsageRatioThreshold","isRented","hasLongIdleHours","isUnassigned","hasHighFuelUsage"],"sources":["D:/ts/my-dashboard/src/mlService.js"],"sourcesContent":["// A simple linear regression model to predict efficiency based on\r\n// engine hours, idle hours, and fuel usage.\r\nconst mlModel = {\r\n  // These weights are manually determined for this example.\r\n  // In a real-world scenario, these would be trained on historical data.\r\n  weights: {\r\n    engineHours: 0.5,\r\n    idleHours: -0.8,\r\n    fuelUsage: -0.2,\r\n    bias: 50, // Base efficiency score\r\n  },\r\n\r\n  // Predicts an efficiency score from 0-100\r\n  predict: (data) => {\r\n    const score = (\r\n      mlModel.weights.engineHours * parseFloat(data['Engine Hours/Day'] || 0) +\r\n      mlModel.weights.idleHours * parseFloat(data['Idle Hours/Day'] || 0) +\r\n      mlModel.weights.fuelUsage * parseFloat(data['Fuel Usage/Day (Liters)'] || 0) +\r\n      mlModel.weights.bias\r\n    );\r\n\r\n    // Clamp the score between 0 and 100\r\n    return Math.max(0, Math.min(100, score)).toFixed(2);\r\n  },\r\n};\r\n\r\nexport const addEfficiencyScores = (equipmentData) => {\r\n  return equipmentData.map(item => ({\r\n    ...item,\r\n    'Efficiency': mlModel.predict(item),\r\n  }));\r\n};\r\n\r\nexport const calculateOperatorScores = (equipmentData) => {\r\n  const operatorData = {};\r\n  const today = new Date();\r\n\r\n  equipmentData.forEach(item => {\r\n    const operatorId = item['Operator ID'];\r\n    if (operatorId && operatorId !== 'NULL') {\r\n      if (!operatorData[operatorId]) {\r\n        operatorData[operatorId] = {\r\n          rentals: [],\r\n          totalEngineHours: 0,\r\n          totalIdleHours: 0,\r\n          overdueCount: 0\r\n        };\r\n      }\r\n      operatorData[operatorId].rentals.push(item);\r\n      operatorData[operatorId].totalEngineHours += parseFloat(item['Engine Hours/Day'] || 0);\r\n      operatorData[operatorId].totalIdleHours += parseFloat(item['Idle Hours/Day'] || 0);\r\n\r\n      const plannedCheckInDate = new Date(item['Planned Check-In Date']);\r\n      if (!item['Actual Check-In Date'] && plannedCheckInDate < today) {\r\n        operatorData[operatorId].overdueCount++;\r\n      }\r\n    }\r\n  });\r\n\r\n  const operatorScores = Object.keys(operatorData).map(operatorId => {\r\n    const data = operatorData[operatorId];\r\n    const avgEngineHours = data.totalEngineHours / data.rentals.length;\r\n    const avgIdleHours = data.totalIdleHours / data.rentals.length;\r\n    \r\n    // A linear model for operator performance.\r\n    // Higher average engine hours and lower average idle hours increase the score.\r\n    // Overdue rentals significantly decrease the score.\r\n    const score = (\r\n      (avgEngineHours * 5) - (avgIdleHours * 2) - (data.overdueCount * 10) + 50\r\n    );\r\n\r\n    return {\r\n      'Operator ID': operatorId,\r\n      'Number of Rentals': data.rentals.length,\r\n      'Average Engine Hours': avgEngineHours.toFixed(2),\r\n      'Average Idle Hours': avgIdleHours.toFixed(2),\r\n      'Overdue Rentals': data.overdueCount,\r\n      'Operator Score': Math.max(0, Math.min(100, score)).toFixed(2)\r\n    };\r\n  });\r\n\r\n  return operatorScores;\r\n};\r\n\r\nexport const demandForecasting = (equipmentData) => {\r\n  const demandPatterns = {};\r\n  equipmentData.forEach(item => {\r\n    const siteId = item['Site ID'];\r\n    const type = item['Type'];\r\n    if (siteId && type) {\r\n      if (!demandPatterns[siteId]) {\r\n        demandPatterns[siteId] = {};\r\n      }\r\n      demandPatterns[siteId][type] = (demandPatterns[siteId][type] || 0) + 1;\r\n    }\r\n  });\r\n\r\n  const forecasts = Object.keys(demandPatterns).map(siteId => {\r\n    const types = demandPatterns[siteId];\r\n    const mostDemandedType = Object.keys(types).reduce((a, b) => types[a] > types[b] ? a : b);\r\n    return {\r\n      'Site ID': siteId,\r\n      'Most Demanded Type': mostDemandedType,\r\n      'Confidence': ((types[mostDemandedType] / Object.values(types).reduce((a,b)=>a+b, 0)) * 100).toFixed(2) + '%'\r\n    };\r\n  });\r\n\r\n  return forecasts;\r\n};\r\n\r\nexport const detectAnomalies = (equipmentData) => {\r\n  const anomalies = [];\r\n  const idleThreshold = 5;\r\n  const fuelUsageRatioThreshold = 6;\r\n\r\n  equipmentData.forEach(item => {\r\n    const isRented = !item['Actual Check-In Date'];\r\n    const hasLongIdleHours = parseFloat(item['Idle Hours/Day']) > idleThreshold;\r\n    const isUnassigned = !item['Site ID'] || item['Site ID'] === 'NULL';\r\n    const fuelUsage = parseFloat(item['Fuel Usage/Day (Liters)'] || 0);\r\n    const engineHours = parseFloat(item['Engine Hours/Day'] || 0);\r\n    const hasHighFuelUsage = engineHours > 0 && (fuelUsage / engineHours) > fuelUsageRatioThreshold;\r\n\r\n    const operatorId = item['Operator ID'] && item['Operator ID'] !== 'NULL' ? item['Operator ID'] : 'N/A';\r\n\r\n    if (isRented && hasLongIdleHours) {\r\n      anomalies.push({\r\n        'Equipment ID': item['Equipment ID'],\r\n        'Equipment Type': item['Type'],\r\n        'Operator ID': operatorId, // Corrected\r\n        'Type': 'High Idle Hours',\r\n        'Details': `Idle time is ${item['Idle Hours/Day']} hours/day, exceeding the threshold of ${idleThreshold}.`\r\n      });\r\n    }\r\n\r\n    if (isRented && isUnassigned) {\r\n      anomalies.push({\r\n        'Equipment ID': item['Equipment ID'],\r\n        'Equipment Type': item['Type'],\r\n        'Operator ID': operatorId, \r\n        'Type': 'Unassigned Equipment',\r\n        'Details': `This equipment has been checked out but is not assigned to a site.`\r\n      });\r\n    }\r\n    \r\n    if (isRented && hasHighFuelUsage) {\r\n      anomalies.push({\r\n        'Equipment ID': item['Equipment ID'],\r\n        'Equipment Type': item['Type'],\r\n        'Operator ID': operatorId, \r\n        'Type': 'High Fuel Usage',\r\n        'Details': `Fuel usage is ${fuelUsage.toFixed(2)} L/day for only ${engineHours.toFixed(2)} engine hours. Ratio exceeds ${fuelUsageRatioThreshold} L/hr.`\r\n      });\r\n    }\r\n  });\r\n\r\n  return anomalies;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}